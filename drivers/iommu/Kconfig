# IOMMU_API always gets selected by whoever wants it.
config IOMMU_API
	bool

menuconfig IOMMU_SUPPORT
	bool "IOMMU Hardware Support"
	default y
	---help---
	  Say Y here if you want to compile device drivers for IO Memory
	  Management Units into the kernel. These devices usually allow to
	  remap DMA requests and/or remap interrupts from other devices on the
	  system.

if IOMMU_SUPPORT

config OF_IOMMU
       def_bool y
       depends on OF

# MSM IOMMU support
config MSM_IOMMU
	bool "MSM IOMMU Support"
	depends on ARCH_MSM8X60 || ARCH_MSM8960
	select IOMMU_API
	help
	  Support for the IOMMUs found on certain Qualcomm SOCs.
	  These IOMMUs allow virtualization of the address space used by most
	  cores within the multimedia subsystem.

	  If unsure, say N here.

config IOMMU_PGTABLES_L2
	def_bool y
	depends on MSM_IOMMU && MMU && SMP && CPU_DCACHE_DISABLE=n

# AMD IOMMU support
config AMD_IOMMU
	bool "AMD IOMMU support"
	select SWIOTLB
	select PCI_MSI
	select PCI_ATS
	select PCI_PRI
	select PCI_PASID
	select IOMMU_API
	depends on X86_64 && PCI && ACPI
	---help---
	  With this option you can enable support for AMD IOMMU hardware in
	  your system. An IOMMU is a hardware component which provides
	  remapping of DMA memory accesses from devices. With an AMD IOMMU you
	  can isolate the the DMA memory of different devices and protect the
	  system from misbehaving device drivers or hardware.

	  You can find out if your system has an AMD IOMMU if you look into
	  your BIOS for an option to enable it or if you have an IVRS ACPI
	  table.

config AMD_IOMMU_STATS
	bool "Export AMD IOMMU statistics to debugfs"
	depends on AMD_IOMMU
	select DEBUG_FS
	---help---
	  This option enables code in the AMD IOMMU driver to collect various
	  statistics about whats happening in the driver and exports that
	  information to userspace via debugfs.
	  If unsure, say N.

config AMD_IOMMU_V2
	tristate "AMD IOMMU Version 2 driver (EXPERIMENTAL)"
	depends on AMD_IOMMU && PROFILING && EXPERIMENTAL
	select MMU_NOTIFIER
	---help---
	  This option enables support for the AMD IOMMUv2 features of the IOMMU
	  hardware. Select this option if you want to use devices that support
	  the the PCI PRI and PASID interface.

# Intel IOMMU support
config DMAR_TABLE
	bool

config INTEL_IOMMU
	bool "Support for Intel IOMMU using DMA Remapping Devices"
	depends on PCI_MSI && ACPI && (X86 || IA64_GENERIC)
	select IOMMU_API
	select DMAR_TABLE
	help
	  DMA remapping (DMAR) devices support enables independent address
	  translations for Direct Memory Access (DMA) from devices.
	  These DMA remapping devices are reported via ACPI tables
	  and include PCI device scope covered by these DMA
	  remapping devices.

config INTEL_IOMMU_DEFAULT_ON
	def_bool y
	prompt "Enable Intel DMA Remapping Devices by default"
	depends on INTEL_IOMMU
	help
	  Selecting this option will enable a DMAR device at boot time if
	  one is found. If this option is not selected, DMAR support can
	  be enabled by passing intel_iommu=on to the kernel.

config INTEL_IOMMU_BROKEN_GFX_WA
	bool "Workaround broken graphics drivers (going away soon)"
	depends on INTEL_IOMMU && BROKEN && X86
	---help---
	  Current Graphics drivers tend to use physical address
	  for DMA and avoid using DMA APIs. Setting this config
	  option permits the IOMMU driver to set a unity map for
	  all the OS-visible memory. Hence the driver can continue
	  to use physical addresses for DMA, at least until this
	  option is removed in the 2.6.32 kernel.

config INTEL_IOMMU_FLOPPY_WA
	def_bool y
	depends on INTEL_IOMMU && X86
	---help---
	  Floppy disk drivers are known to bypass DMA API calls
	  thereby failing to work when IOMMU is enabled. This
	  workaround will setup a 1:1 mapping for the first
	  16MiB to make floppy (an ISA device) work.

config IRQ_REMAP
	bool "Support for Interrupt Remapping (EXPERIMENTAL)"
	depends on X86_64 && X86_IO_APIC && PCI_MSI && ACPI && EXPERIMENTAL
	select DMAR_TABLE
	---help---
	  Supports Interrupt remapping for IO-APIC and MSI devices.
	  To use x2apic mode in the CPU's which support x2APIC enhancements or
	  to support platforms with CPU's having > 8 bit APIC ID, say Y.

# OMAP IOMMU support
config OMAP_IOMMU
	bool "OMAP IOMMU Support"
	depends on ARCH_OMAP
	select IOMMU_API

config OMAP_IOVMM
	tristate "OMAP IO Virtual Memory Manager Support"
	depends on OMAP_IOMMU

config OMAP_IOMMU_DEBUG
       tristate "Export OMAP IOMMU/IOVMM internals in DebugFS"
       depends on OMAP_IOVMM && DEBUG_FS
       help
         Select this to see extensive information about
         the internal state of OMAP IOMMU/IOVMM in debugfs.

         Say N unless you know you need this.

config TEGRA_IOMMU_GART
	bool "Tegra GART IOMMU Support"
	depends on ARCH_TEGRA_2x_SOC
	select IOMMU_API
	help
	  Enables support for remapping discontiguous physical memory
	  shared with the operating system into contiguous I/O virtual
	  space through the GART (Graphics Address Relocation Table)
	  hardware included on Tegra 2 SoCs.

config TEGRA_IOMMU_SMMU
	bool "Tegra SMMU IOMMU Support"
	depends on ARCH_TEGRA_3x_SOC || ARCH_TEGRA_11x_SOC
	select IOMMU_API
	help
	  Enables support for remapping discontiguous physical memory
	  shared with the operating system into contiguous I/O virtual
	  space through the SMMU (System Memory Management Unit)
	  hardware included on Tegra 3 SoCs and later.

config TEGRA_IOMMU_SMMU_LINEAR
	bool "Physical RAM IOVA Liner Mapping Support"
	depends on TEGRA_IOMMU_SMMU && !PLATFORM_ENABLE_IOMMU
	default y
	help
	  Enables support for linear mapping between physical address
	  and IO virtual address for RAM. With this enabled, H/W can
	  expect virt_to_phys() to work even if it's behined the
	  IOMMU'able bus. Otherwise DMA API should be used correctly
	  in device drivers.

config TEGRA_ERRATA_1053704
	bool "Tegra errata: SMMU Hit-Under-Miss FIFO Out-of-Order"
	depends on TEGRA_IOMMU_SMMU
	depends on ARCH_TEGRA_3x_SOC || ARCH_TEGRA_11x_SOC
	help
	  SMMU TLB entry invalidate, while hit-under-miss(HUM) FIFO
	  has pending transaction(s) based on the TLB entry, can cause
	  violation of transactions ordering requirement at SMMU, if
	  the subsequent transaction to the same IOVA address gets PTE
	  into a different TLB entry. If this happens, The new
	  transaction(s) can bypass pending transaction(s) and can
	  lead to memory corruption. The workaround is not to flush
	  TLB entry, which has pending transactions in HUM FIFO.

endif # IOMMU_SUPPORT
